import tensorflow as tf
import os
from skimage.io import imread
import progressbar

import numpy as np
from data.gene_label import COLOR_MAPS


class Img(object):
    def __init__(self, img_path, label_path):
        self.img_path = img_path
        self.label_path = label_path


def _int64_feature(value):
    return tf.train.Feature(int64_list=tf.train.Int64List(value=[value]))


def _bytes_feature(value):
    return tf.train.Feature(bytes_list=tf.train.BytesList(value=[value]))


def convert_to(img_list, target_dir, color_maps, name="train"):
    """
    build records file
    :param img_list: a list of Img objects generated by 'parse_txt_file'
    :param target_dir: the target directory that you want to save the records file
    :param name: using to specify the record file's name. the generated file name is 'name.tfrecords'
    :return: Nothing
    """
    if not isinstance(img_list, list):
        raise ValueError("img_list must be a list")

    total_num = len(img_list)

    ####
    widgets = ["processing: ", progressbar.Percentage(),
               " ", progressbar.ETA(),
               " ", progressbar.FileTransferSpeed(),
               ]
    bar = progressbar.ProgressBar(widgets=widgets, max_value=total_num).start()
    ####

    filename = os.path.join(target_dir, name + '.tfrecords')
    print('Writing', filename)
    writer = tf.python_io.TFRecordWriter(filename)
    for i, img in enumerate(img_list):
        bar.update(i)
        img_data = imread(img.img_path)
        img_label = imread(img.label_path)
        img_label = semantic_img2class(img_label, color_maps)
        height = img_data.shape[0]
        width = img_data.shape[1]
        depth = img_data.shape[2]
        img_data_raw = img_data.tostring()
        img_label_raw = img_label.tostring()
        example = tf.train.Example(features=tf.train.Features(feature={
            'height': _int64_feature(height),
            'width': _int64_feature(width),
            'depth': _int64_feature(depth),
            'label': _bytes_feature(img_label_raw),
            'image_raw': _bytes_feature(img_data_raw)}))
        writer.write(example.SerializeToString())
    writer.close()
    bar.finish()
    print("done")


def semantic_img2class(img, color_maps):
    if not isinstance(img, np.ndarray):
        raise ValueError("img must be ndarray, not the %s" % type(img))
    labels = []
    height, width, _ = img.shape
    for i in range(height):
        row_label = []
        for j in range(width):
            color = list(img[i, j])
            label = color_maps.index(color)
            row_label.append(label)
        labels.append(row_label)

    labels = np.array(labels).astype(np.uint8)
    return labels


def suffix_png2jpg(name):
    name, suffix = name.split('.')
    name += '.jpg'
    return name


def generate_Img_list(img_dir, label_dir):
    labels = os.listdir(label_dir)
    labels_abs_path = [os.path.join(label_dir, label) for label in labels]
    imgs_abs_path = [os.path.join(img_dir, suffix_png2jpg(img)) for img in labels]
    num_data = len(labels)
    Img_list = []
    for i, img_path in enumerate(imgs_abs_path):
        img_obj = Img(img_path, label_path=labels_abs_path[i])
        Img_list.append(img_obj)
    print("number of data %d" % num_data)
    return Img_list


def main():
    img_dir = '/media/fanyang/workspace/DataSet/VOCdevkit/VOC2012/JPEGImages'
    label_dir = '/media/fanyang/workspace/DataSet/VOCdevkit/VOC2012/SegmentationClass'
    target_dir = '/media/fanyang/workspace/DataSet/VOCdevkit/VOC2012'
    NUM_DATA = 2913
    Img_list = generate_Img_list(img_dir=img_dir, label_dir=label_dir)
    convert_to(img_list=Img_list, target_dir=target_dir, color_maps=COLOR_MAPS, name="semantic_2012_train")
    pass


if __name__ == '__main__':
    main()
